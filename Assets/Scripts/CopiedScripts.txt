// Auto-Generated Dump
// Source: Assets/Scripts
// Updated: 12/19/2025 5:47:15 PM

===== FILE: BackgroundMusicManager.cs =====
using UnityEngine;

public class BackgroundMusicManager : MonoBehaviour
{
    public static BackgroundMusicManager Instance;
    private AudioSource audioSource;

    void Awake()
    {
        // Singleton Pattern: Es darf nur EINEN MusicManager geben
        if (Instance == null)
        {
            Instance = this;
            // WICHTIG: Dieses Objekt �berlebt den Szenenwechsel!
            DontDestroyOnLoad(gameObject);

            // AudioSource holen oder hinzuf�gen
            audioSource = GetComponent<AudioSource>();
            if (audioSource == null)
            {
                audioSource = gameObject.AddComponent<AudioSource>();
            }

            // Einstellungen sicherstellen
            audioSource.loop = true; // Endlosschleife
            audioSource.playOnAwake = false; // Nicht sofort starten (erst nach Splash)
        }
        else
        {
            // Wenn es schon einen gibt (z.B. nach Reload), zerst�re den neuen sofort
            Destroy(gameObject);
        }
    }

    public void StartMusic()
    {
        // Nur starten, wenn sie nicht eh schon l�uft!
        if (!audioSource.isPlaying)
        {
            audioSource.Play();
        }
    }

    // Optional: Falls du die Musik sp�ter mal leiser machen willst
    public void SetVolume(float volume)
    {
        audioSource.volume = volume;
    }
}
===== END: BackgroundMusicManager.cs =====


===== FILE: DeliveryZone.cs =====
using UnityEngine;

public class DeliveryZone : MonoBehaviour
{
    // Ziehe hier im Inspektor dein Haupt-Zug-Objekt rein (wo der TrainController drauf liegt)
    public TrainController trainController;

    private void OnTriggerStay(Collider other)
    {
        // Wir pr�fen nur, ob es der Spieler ist
        if (other.CompareTag("Player"))
        {
            // Wir leiten den Spieler an den Zug weiter
            if (trainController != null)
            {
                trainController.AttemptDelivery(other.GetComponent<PlayerController>());
            }
        }
    }
}
===== END: DeliveryZone.cs =====


===== FILE: GameManager.cs =====
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.InputSystem;
using TMPro;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    // Statische Variable, die den Szenenwechsel �berlebt
    // Wenn true, starten wir direkt ins Spiel (Skip Splash & Menu)
    private static bool restartDirectly = false;

    [Header("UI Panels")]
    public GameObject splashPanel;
    public GameObject menuPanel;
    public GameObject gamePanel;
    public GameObject resultsPanel;

    [Header("Game UI Elements (TMP)")]
    public TMP_Text roundText;         // Aktuelle Runde oben im Spiel
    public TMP_Text highestRoundText;  // Rekord oben im Spiel
    public TMP_Text livesText;

    [Header("Results UI")]
    public TMP_Text finalRoundText;    // Text im Game Over Screen (Ergebnis)

    [Header("Settings")]
    public int maxLives = 3;
    public float splashDuration = 8.0f;

    public enum GameState { Splash, Menu, Game, Results }
    public GameState CurrentState { get; private set; }

    // Runden-Logik
    private int currentRound;
    private int highestRound;
    private int currentLives;
    private float timer;

    void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    void Start()
    {
        // Laden der h�chsten Runde
        highestRound = PlayerPrefs.GetInt("HighestRound", 1);
        UpdateGameUI();

        // CHECK: Kommen wir von einem "Restart"?
        if (restartDirectly)
        {
            restartDirectly = false; // Flag zur�cksetzen
            StartGame(); // Sofort ins Spiel starten!
        }
        else
        {
            // Normaler Start -> Splash Screen zeigen
            ChangeState(GameState.Splash);
        }
    }

    void Update()
    {
        // Logik f�r den Splash Screen
        if (CurrentState == GameState.Splash)
        {
            timer += Time.deltaTime;
            bool inputDetected = false;

            if (Mouse.current != null && Mouse.current.leftButton.wasPressedThisFrame) inputDetected = true;
            if (Keyboard.current != null && Keyboard.current.anyKey.wasPressedThisFrame) inputDetected = true;
            if (Gamepad.current != null && Gamepad.current.buttonSouth.wasPressedThisFrame) inputDetected = true;

            if (timer >= splashDuration || inputDetected)
            {
                SkipSplash();
            }
        }
    }

    public void SkipSplash()
    {
        if (CurrentState == GameState.Splash)
        {
            ChangeState(GameState.Menu);
        }
    }

    public void ChangeState(GameState newState)
    {
        CurrentState = newState;

        if (splashPanel) splashPanel.SetActive(false);
        if (menuPanel) menuPanel.SetActive(false);
        if (gamePanel) gamePanel.SetActive(false);
        if (resultsPanel) resultsPanel.SetActive(false);

        switch (newState)
        {
            case GameState.Splash:
                if (splashPanel) splashPanel.SetActive(true);
                timer = 0f;
                break;

            case GameState.Menu:
                if (menuPanel) menuPanel.SetActive(true);
                if (BackgroundMusicManager.Instance != null)
                    BackgroundMusicManager.Instance.StartMusic();

                // Im Men� schon den Rekord anzeigen
                if (highestRoundText) highestRoundText.text = $"Best Round: {highestRound}";
                break;

            case GameState.Game:
                if (gamePanel) gamePanel.SetActive(true);
                UpdateGameUI();
                break;

            case GameState.Results:
                if (resultsPanel) resultsPanel.SetActive(true);
                // Ergebnis anzeigen: Zeige Runde und Rekord
                if (finalRoundText)
                {
                    finalRoundText.text = $"GAME OVER\n\nYou reached Round: {currentRound}\n\nHighest Round: {highestRound}";
                }
                break;
        }
    }

    public void StartGame()
    {
        currentLives = maxLives;
        currentRound = 1;

        // WICHTIG: Spawner komplett zur�cksetzen (auch Speed)
        if (SnowmanSpawner.Instance != null) SnowmanSpawner.Instance.ResetSpawner();

        UpdateGameUI();
        ChangeState(GameState.Game);
    }

    // Wird vom TrainController aufgerufen
    public void OnTrainDeparted(bool wasFull)
    {
        if (CurrentState != GameState.Game) return;

        if (wasFull)
        {
            // Zug voll -> N�chste Runde
            currentRound++;

            // Rekord pr�fen
            if (currentRound > highestRound)
            {
                highestRound = currentRound;
                PlayerPrefs.SetInt("HighestRound", highestRound);
                PlayerPrefs.Save();
            }

            // --- SCHWIERIGKEITSGRAD ---
            if (SnowmanSpawner.Instance != null)
            {
                if (currentRound <= 7)
                {
                    // Bis Runde 7: Mehr Schneem�nner
                    SnowmanSpawner.Instance.SpawnSnowman();
                }
                else
                {
                    // Ab Runde 7: Schneem�nner werden schneller!
                    SnowmanSpawner.Instance.IncreaseGlobalSpeed(1.0f);
                }
            }
        }
        else
        {
            // Zug nicht voll -> Leben weg
            currentLives--;
            if (currentLives <= 0)
            {
                TriggerGameOver();
                return;
            }
        }

        UpdateGameUI();
    }

    void UpdateGameUI()
    {
        if (livesText) livesText.text = $"Lives: {currentLives}";
        if (roundText) roundText.text = $"Round: {currentRound}";
        if (highestRoundText) highestRoundText.text = $"Best: {highestRound}";
    }

    public void TriggerGameOver()
    {
        ChangeState(GameState.Results);
    }

    public bool IsGameRunning() => CurrentState == GameState.Game;

    // --- UI Button Callbacks ---
    public void OnStartGameButton() => StartGame();

    public void OnRestartButton()
    {
        // Wir setzen das Flag, damit wir beim Neuladen den Splash �berspringen
        restartDirectly = true;
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }

    public void OnQuitButton() => Application.Quit();
}
===== END: GameManager.cs =====


===== FILE: GiftDespawner.cs =====
using UnityEngine;

public class GiftDespawner : MonoBehaviour
{
    [Header("Settings")]
    public float lifetime = 10f; // Wie lange existiert es insgesamt?
    public float startBlinkingAt = 3f; // Ab wann (Restzeit) soll es blinken?

    [Header("Blink Speed")]
    public float slowBlinkInterval = 0.5f; // Langsames Blinken (Anfang)
    public float fastBlinkInterval = 0.1f; // Schnelles Flackern (Ende)

    private float age;
    private float blinkTimer;
    private Renderer[] renderers; // Alle MeshRenderer (falls das Geschenk aus mehreren Teilen besteht)
    private bool isVisible = true;

    void Start()
    {
        // Wir holen uns alle Renderer (auch von Kind-Objekten), damit das ganze Geschenk blinkt
        renderers = GetComponentsInChildren<Renderer>();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;

        age += Time.deltaTime;
        float remainingTime = lifetime - age;

        // 1. Zeit abgelaufen? -> Weg damit
        if (remainingTime <= 0)
        {
            Destroy(gameObject);
            return;
        }

        // 2. Soll es blinken? (Nur in den letzten X Sekunden)
        if (remainingTime <= startBlinkingAt)
        {
            HandleBlinking(remainingTime);
        }
    }

    void HandleBlinking(float remainingTime)
    {
        // Berechne, wie weit wir im Blink-Prozess sind (0 = Start Blinken, 1 = Tot)
        // Wir kehren den Wert um, damit 1.0 = Start (3 sek) und 0.0 = Ende (0 sek) ist, das macht Lerp einfacher
        float progress = remainingTime / startBlinkingAt;

        // Lerp: Wir berechnen das aktuelle Intervall basierend auf der Restzeit.
        // Wenn noch viel Zeit ist (progress 1), nutzen wir slowBlinkInterval.
        // Wenn wenig Zeit ist (progress 0), nutzen wir fastBlinkInterval.
        float currentInterval = Mathf.Lerp(fastBlinkInterval, slowBlinkInterval, progress);

        blinkTimer += Time.deltaTime;

        // Ist es Zeit den Status zu wechseln?
        if (blinkTimer >= currentInterval)
        {
            ToggleVisuals();
            blinkTimer = 0f;
        }
    }

    void ToggleVisuals()
    {
        isVisible = !isVisible;

        // Alle Renderer an/ausschalten
        foreach (var rend in renderers)
        {
            rend.enabled = isVisible;
        }
    }
}
===== END: GiftDespawner.cs =====


===== FILE: GiftSpawner.cs =====
using UnityEngine;

public class GiftSpawner : MonoBehaviour
{
    [Header("Geschenke Varianten")]
    public GameObject giftPrefabA; // Erstes Design (z.B. Rot)
    public GameObject giftPrefabB; // Zweites Design (z.B. Blau)

    [Header("Settings")]
    public float spawnInterval = 2.0f;
    public float spawnY = 0.5f;

    [Header("Spawn Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;

    private float timer;
    private bool spawnNextTypeA = true; // Schalter f�r Abwechslung

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;

        timer += Time.deltaTime;

        if (timer >= spawnInterval)
        {
            SpawnAlternatingGift();
            timer = 0f;
        }
    }

    void SpawnAlternatingGift()
    {
        // Zufallsposition
        float randomX = Random.Range(minX, maxX);
        float randomZ = Random.Range(minZ, maxZ);
        Vector3 spawnPos = new Vector3(randomX, spawnY, randomZ);

        // Welches Prefab?
        GameObject prefabToSpawn = spawnNextTypeA ? giftPrefabA : giftPrefabB;

        if (prefabToSpawn != null)
        {
            Instantiate(prefabToSpawn, spawnPos, Quaternion.identity);
        }

        // Schalter umlegen f�r das n�chste Mal
        spawnNextTypeA = !spawnNextTypeA;
    }
}
===== END: GiftSpawner.cs =====


===== FILE: PlayerController.cs =====
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using TMPro;

[RequireComponent(typeof(CharacterController))]
public class PlayerController : MonoBehaviour
{
    [Header("Movement & Speed")]
    public float baseMoveSpeed = 10f;
    public float rotateSpeed = 10f;
    public TMP_Text speedDisplayUI;

    [Header("Boundaries")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;
    public float fixedY = 0f;

    [Header("Animation")]
    public Animator animator;
    public bool useAnimation = true;
    // Dieser Parameter steuert den Wechsel zwischen Idle (false) und Run (true) im Animator
    public string moveParameterName = "IsMoving";

    [Header("Stack Settings")]
    public Transform stackPoint;
    public float stackOffsetY = 0.9f;
    public float stackOffsetZ = 0.6f;
    public int maxStackSize = 20;

    private CharacterController controller;
    private List<GameObject> currentStack = new List<GameObject>();
    private float currentSpeed;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        if (animator == null) animator = GetComponentInChildren<Animator>();
        UpdateSpeedAndUI();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning())
        {
            if (useAnimation && animator != null) animator.SetBool(moveParameterName, false);
            return;
        }
        Move();
    }

    void Move()
    {
        float x = 0f;
        float z = 0f;
        if (Keyboard.current != null)
        {
            if (Keyboard.current.aKey.isPressed || Keyboard.current.leftArrowKey.isPressed) x -= 1f;
            if (Keyboard.current.dKey.isPressed || Keyboard.current.rightArrowKey.isPressed) x += 1f;
            if (Keyboard.current.sKey.isPressed || Keyboard.current.downArrowKey.isPressed) z -= 1f;
            if (Keyboard.current.wKey.isPressed || Keyboard.current.upArrowKey.isPressed) z += 1f;
        }
        Vector3 direction = new Vector3(x, 0, z).normalized;
        bool isMoving = direction.magnitude >= 0.1f;

        // Hier wird der Animator gesteuert:
        // isMoving = true -> Lauf-Animation
        // isMoving = false -> Idle-Animation
        if (useAnimation && animator != null) animator.SetBool(moveParameterName, isMoving);

        if (isMoving)
        {
            float targetAngle = Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(0f, targetAngle, 0f), Time.deltaTime * rotateSpeed);
            Vector3 moveVector = direction * currentSpeed * Time.deltaTime;
            controller.Move(moveVector);
        }

        Vector3 finalPos = transform.position;
        finalPos.x = Mathf.Clamp(finalPos.x, minX, maxX);
        finalPos.z = Mathf.Clamp(finalPos.z, minZ, maxZ);
        finalPos.y = fixedY;
        transform.position = finalPos;
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Gift"))
        {
            if (currentStack.Count < maxStackSize) CollectGift(other.gameObject);
        }
        else if (other.CompareTag("Snowman"))
        {
            DropAllGifts();
        }
    }

    void CollectGift(GameObject groundGift)
    {
        Collider col = groundGift.GetComponent<Collider>();
        if (col != null) col.enabled = false;

        // BUG FIX: Renderer erzwingen
        Renderer[] renderers = groundGift.GetComponentsInChildren<Renderer>();
        foreach (var rend in renderers)
        {
            rend.enabled = true;
        }

        GiftDespawner despawner = groundGift.GetComponent<GiftDespawner>();
        if (despawner != null) Destroy(despawner);

        groundGift.transform.SetParent(stackPoint);
        float newY = currentStack.Count * stackOffsetY;
        groundGift.transform.localPosition = new Vector3(0f, newY, stackOffsetZ);
        groundGift.transform.localRotation = Quaternion.identity;
        currentStack.Add(groundGift);
        UpdateSpeedAndUI();
    }

    void DropAllGifts()
    {
        if (currentStack.Count == 0) return;
        foreach (var gift in currentStack)
        {
            gift.transform.SetParent(null);
            Vector2 randomCircle = Random.insideUnitCircle * 3f;
            Vector3 dropPos = transform.position + new Vector3(randomCircle.x, 0.5f, randomCircle.y);
            dropPos.x = Mathf.Clamp(dropPos.x, minX, maxX);
            dropPos.z = Mathf.Clamp(dropPos.z, minZ, maxZ);

            gift.transform.position = dropPos;
            gift.transform.rotation = Quaternion.identity;

            Collider col = gift.GetComponent<Collider>();
            if (col != null) col.enabled = true;

            Renderer[] renderers = gift.GetComponentsInChildren<Renderer>();
            foreach (var r in renderers) r.enabled = true;

            if (gift.GetComponent<GiftDespawner>() == null)
                gift.AddComponent<GiftDespawner>();
        }
        currentStack.Clear();
        UpdateSpeedAndUI();
    }

    void UpdateSpeedAndUI()
    {
        float fullness = (float)currentStack.Count / (float)maxStackSize;
        float speedFactor = 1.0f - (0.5f * fullness);
        currentSpeed = baseMoveSpeed * speedFactor;

        if (speedDisplayUI != null)
        {
            int displayPercent = Mathf.RoundToInt(speedFactor * 100);
            speedDisplayUI.text = $"Speed: {displayPercent}%";
            if (displayPercent > 75) speedDisplayUI.color = Color.green;
            else if (displayPercent > 50) speedDisplayUI.color = Color.yellow;
            else speedDisplayUI.color = Color.red;
        }
    }

    public int GiveGifts(int neededAmount)
    {
        int amountToGive = Mathf.Min(currentStack.Count, neededAmount);
        for (int i = 0; i < amountToGive; i++)
        {
            int lastIndex = currentStack.Count - 1;
            GameObject gift = currentStack[lastIndex];
            currentStack.RemoveAt(lastIndex);
            Destroy(gift);
        }
        UpdateSpeedAndUI();
        return amountToGive;
    }
}
===== END: PlayerController.cs =====


===== FILE: PulsingText.cs =====
using UnityEngine;
using TMPro;

/// <summary>
/// Creates a gentle pulsing effect by modifying the font size of a TextMeshPro object over time.
/// Used to draw attention to UI elements.
/// </summary>
public class PulsingText : MonoBehaviour
{
    [Header("Settings")]
    public float minSize = 80f;     // Minimum font size
    public float maxSize = 110f;    // Maximum font size
    public float speed = 5f;        // Speed of the pulse wave

    private TMP_Text textMesh;

    private void Start()
    {
        // Automatically grab the TMP component from this GameObject
        textMesh = GetComponent<TMP_Text>();
    }

    private void Update()
    {
        if (textMesh == null) return;

        // Generate a value that oscillates smoothly between 0 and 1 using Sine
        // Mathf.Sin returns -1 to 1; we shift and scale it to 0 to 1
        float wave = (Mathf.Sin(Time.time * speed) + 1f) / 2f;

        // Interpolate between min and max size based on the wave value
        textMesh.fontSize = Mathf.Lerp(minSize, maxSize, wave);
    }
}
===== END: PulsingText.cs =====


===== FILE: SnowmanController.cs =====
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(CharacterController))]
public class SnowmanController : MonoBehaviour
{
    [Header("Movement")]
    public float moveSpeed = 3f; // Wird vom Spawner �berschrieben
    public float waitTime = 2f;
    public float rotateSpeed = 5f;

    [Header("Wander Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;
    public float fixedY = 0f;

    [Header("Model Correction")]
    public float xRotationCorrection = -90f;

    private Vector3 targetPosition;
    private float timer;
    private bool isWaiting;
    private bool isSpawning = true;

    private CharacterController controller;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        // Rotation korrigieren
        transform.rotation = Quaternion.Euler(xRotationCorrection, 0f, 0f);
        StartCoroutine(RiseFromGround());
    }

    // Methode zum �ndern der Geschwindigkeit
    public void SetSpeed(float newSpeed)
    {
        moveSpeed = newSpeed;
    }

    IEnumerator RiseFromGround()
    {
        isSpawning = true;
        Vector3 startPos = transform.position;
        Vector3 endPos = new Vector3(startPos.x, fixedY, startPos.z);
        float elapsed = 0f;
        float duration = 1.5f;

        while (elapsed < duration)
        {
            transform.position = Vector3.Lerp(startPos, endPos, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.position = endPos;
        isSpawning = false;
        SetNewRandomTarget();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;
        if (isSpawning) return;

        // Rotations-Korrektur (X-Achse festnageln)
        float currentYRot = transform.rotation.eulerAngles.y;
        transform.rotation = Quaternion.Euler(xRotationCorrection, currentYRot, 0f);

        if (isWaiting)
        {
            timer -= Time.deltaTime;
            if (timer <= 0)
            {
                isWaiting = false;
                SetNewRandomTarget();
            }
        }
        else
        {
            MoveToTarget();
        }
    }

    void MoveToTarget()
    {
        Vector3 direction = (targetPosition - transform.position).normalized;
        direction.y = 0;

        if (direction != Vector3.zero)
        {
            // Rotation berechnen
            Quaternion targetRot = Quaternion.LookRotation(direction);
            Quaternion correctedTargetRot = Quaternion.Euler(xRotationCorrection, targetRot.eulerAngles.y, 0f);
            transform.rotation = Quaternion.Slerp(transform.rotation, correctedTargetRot, Time.deltaTime * rotateSpeed);

            // Bewegung
            Vector3 moveVector = direction * moveSpeed * Time.deltaTime;
            controller.Move(moveVector);
        }

        // Ziel-Check (flach)
        Vector3 flatPos = new Vector3(transform.position.x, 0, transform.position.z);
        Vector3 flatTarget = new Vector3(targetPosition.x, 0, targetPosition.z);

        if (Vector3.Distance(flatPos, flatTarget) < 0.2f)
        {
            isWaiting = true;
            timer = waitTime;
        }

        // Position auf Boden zwingen
        Vector3 clampedPos = transform.position;
        clampedPos.y = fixedY;
        transform.position = clampedPos;
    }

    void SetNewRandomTarget()
    {
        float x = Random.Range(minX, maxX);
        float z = Random.Range(minZ, maxZ);
        targetPosition = new Vector3(x, fixedY, z);
    }
}
===== END: SnowmanController.cs =====


===== FILE: SnowmanSpawner.cs =====
using UnityEngine;
using System.Collections.Generic;

public class SnowmanSpawner : MonoBehaviour
{
    public static SnowmanSpawner Instance;

    public GameObject snowmanPrefab;
    public int maxSnowmen = 7;

    [Header("Spawn Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;

    [Header("Difficulty")]
    public float initialSpeed = 3f; // Startgeschwindigkeit
    private float currentGlobalSpeed;

    private List<GameObject> activeSnowmen = new List<GameObject>();

    void Awake()
    {
        Instance = this;
        currentGlobalSpeed = initialSpeed;
    }

    void Update()
    {
        // Erster Schneemann spawnt automatisch beim Start, wenn Liste leer
        if (GameManager.Instance.IsGameRunning() && activeSnowmen.Count == 0)
        {
            SpawnSnowman();
        }
    }

    public void SpawnSnowman()
    {
        if (activeSnowmen.Count >= maxSnowmen) return;

        float randomX = Random.Range(minX, maxX);
        float randomZ = Random.Range(minZ, maxZ);
        Vector3 spawnPos = new Vector3(randomX, -2f, randomZ);

        GameObject newSnowman = Instantiate(snowmanPrefab, spawnPos, Quaternion.identity);

        // Speed sofort setzen
        SnowmanController sc = newSnowman.GetComponent<SnowmanController>();
        if (sc != null) sc.SetSpeed(currentGlobalSpeed);

        activeSnowmen.Add(newSnowman);
    }

    // Neue Funktion: Alle schneller machen
    public void IncreaseGlobalSpeed(float amount)
    {
        currentGlobalSpeed += amount;

        // Alle aktiven updaten
        foreach (var snowman in activeSnowmen)
        {
            if (snowman != null)
            {
                SnowmanController sc = snowman.GetComponent<SnowmanController>();
                if (sc != null) sc.SetSpeed(currentGlobalSpeed);
            }
        }
    }

    // Reset Funktion f�r neues Spiel
    public void ResetSpawner()
    {
        foreach (var snowman in activeSnowmen)
        {
            if (snowman != null) Destroy(snowman);
        }
        activeSnowmen.Clear();
        currentGlobalSpeed = initialSpeed; // Speed zur�cksetzen!
    }
}
===== END: SnowmanSpawner.cs =====


===== FILE: TrainController.cs =====
using UnityEngine;
using UnityEngine.UI;
using TMPro;

[RequireComponent(typeof(AudioSource))]
public class TrainController : MonoBehaviour
{
    [Header("Settings")]
    public float speed = 15f;
    public float waitTime = 10f;
    public float spawnX = 60f;
    public float stopX = 0f;
    public float despawnX = -80f;
    public int giftsNeededPerRound = 10;

    [Header("Start Delay")]
    // HIER GE�NDERT: Von 5.0f auf 7.0f erh�ht
    public float initialStartDelay = 7.0f; // Nur in Runde 1

    [Header("Collision")]
    public Collider deliveryZoneCollider;

    [Header("Audio")]
    public AudioClip arrivalSound;

    [Header("Visuals")]
    public GameObject emptyWagonVisual;
    public GameObject fullWagonVisual;

    [Header("UI (World Space)")]
    public Slider timerSlider;
    public Slider cargoSlider;
    public TMP_Text cargoText;

    // Zust�nde
    private bool isWaiting = false;
    private bool isLeaving = false;
    private bool isInStartDelay = false;

    private float currentWaitTimer;
    private float startDelayTimer;

    private int currentGifts = 0;
    private int requiredGifts;
    private AudioSource audioSource;

    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.playOnAwake = false;
        audioSource.loop = false;

        if (deliveryZoneCollider != null) deliveryZoneCollider.enabled = false;

        // Reset mit "true" f�r erste Runde (Delay)
        ResetTrain(true);
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning())
        {
            if (audioSource.isPlaying) audioSource.Pause();
            return;
        }
        else
        {
            audioSource.UnPause();
        }

        // Start Verz�gerung (nur Runde 1)
        if (isInStartDelay)
        {
            startDelayTimer -= Time.deltaTime;
            if (startDelayTimer <= 0)
            {
                isInStartDelay = false;
                PlayArrivalSound();
            }
            return;
        }

        // 1. Einfahren
        if (!isWaiting && !isLeaving)
        {
            Vector3 targetPos = new Vector3(stopX, transform.position.y, transform.position.z);
            transform.position = Vector3.MoveTowards(transform.position, targetPos, speed * Time.deltaTime);

            if (Mathf.Abs(transform.position.x - stopX) < 0.1f)
            {
                StartWaiting();
            }
        }
        // 2. Warten
        else if (isWaiting)
        {
            currentWaitTimer -= Time.deltaTime;
            if (timerSlider) timerSlider.value = currentWaitTimer / waitTime;

            if (currentWaitTimer <= 0)
            {
                Depart();
            }
        }
        // 3. Abfahren
        else if (isLeaving)
        {
            transform.Translate(Vector3.left * speed * Time.deltaTime);

            // Wenn Zug weg ist -> Reset
            if (transform.position.x < despawnX)
            {
                // GameManager k�mmert sich um Schneem�nner und Runden, wir resetten nur den Zug
                ResetTrain(false);
            }
        }
    }

    void StartWaiting()
    {
        isWaiting = true;
        currentWaitTimer = waitTime;

        currentGifts = 0;
        requiredGifts = giftsNeededPerRound;

        if (deliveryZoneCollider != null) deliveryZoneCollider.enabled = true;
        UpdateUI();
    }

    void Depart()
    {
        isWaiting = false;
        isLeaving = true;

        if (deliveryZoneCollider != null) deliveryZoneCollider.enabled = false;

        // Abrechnung
        bool isFull = (currentGifts >= requiredGifts);

        if (GameManager.Instance != null)
        {
            GameManager.Instance.OnTrainDeparted(isFull);
        }
    }

    void ResetTrain(bool initial)
    {
        transform.position = new Vector3(spawnX, transform.position.y, transform.position.z);
        isLeaving = false;
        isWaiting = false;

        if (deliveryZoneCollider != null) deliveryZoneCollider.enabled = false;
        SetWagonVisuals(false);

        if (initial)
        {
            // Runde 1: Delay
            isInStartDelay = true;
            startDelayTimer = initialStartDelay;

            currentGifts = 0;
            requiredGifts = giftsNeededPerRound;
            UpdateUI();

            // Spawner Reset
            if (SnowmanSpawner.Instance != null) SnowmanSpawner.Instance.ResetSpawner();
        }
        else
        {
            // Folgerunden: Sofort Sound
            PlayArrivalSound();
        }
    }

    void PlayArrivalSound()
    {
        if (arrivalSound != null)
        {
            audioSource.clip = arrivalSound;
            audioSource.Play();
        }
    }

    void SetWagonVisuals(bool isFull)
    {
        if (emptyWagonVisual) emptyWagonVisual.SetActive(!isFull);
        if (fullWagonVisual) fullWagonVisual.SetActive(isFull);
    }

    void UpdateUI()
    {
        if (cargoText != null)
            cargoText.text = $"{currentGifts} / {requiredGifts}";

        if (cargoSlider != null)
        {
            if (requiredGifts > 0)
                cargoSlider.value = (float)currentGifts / (float)requiredGifts;
            else
                cargoSlider.value = 1f;
        }
    }

    public void AttemptDelivery(PlayerController player)
    {
        if (isWaiting && player != null)
        {
            int missing = requiredGifts - currentGifts;
            if (missing > 0)
            {
                int taken = player.GiveGifts(missing);
                if (taken > 0)
                {
                    currentGifts += taken;
                    UpdateUI();
                    if (currentGifts >= requiredGifts)
                    {
                        SetWagonVisuals(true);
                    }
                }
            }
        }
    }
}
===== END: TrainController.cs =====


