// Auto-Generated Dump
// Source: Assets/Scripts
// Updated: 12/19/2025 3:12:20 PM

===== FILE: BackgroundMusicManager.cs =====
using UnityEngine;

public class BackgroundMusicManager : MonoBehaviour
{
    public static BackgroundMusicManager Instance;
    private AudioSource audioSource;

    void Awake()
    {
        // Singleton Pattern: Es darf nur EINEN MusicManager geben
        if (Instance == null)
        {
            Instance = this;
            // WICHTIG: Dieses Objekt �berlebt den Szenenwechsel!
            DontDestroyOnLoad(gameObject);

            // AudioSource holen oder hinzuf�gen
            audioSource = GetComponent<AudioSource>();
            if (audioSource == null)
            {
                audioSource = gameObject.AddComponent<AudioSource>();
            }

            // Einstellungen sicherstellen
            audioSource.loop = true; // Endlosschleife
            audioSource.playOnAwake = false; // Nicht sofort starten (erst nach Splash)
        }
        else
        {
            // Wenn es schon einen gibt (z.B. nach Reload), zerst�re den neuen sofort
            Destroy(gameObject);
        }
    }

    public void StartMusic()
    {
        // Nur starten, wenn sie nicht eh schon l�uft!
        if (!audioSource.isPlaying)
        {
            audioSource.Play();
        }
    }

    // Optional: Falls du die Musik sp�ter mal leiser machen willst
    public void SetVolume(float volume)
    {
        audioSource.volume = volume;
    }
}
===== END: BackgroundMusicManager.cs =====


===== FILE: GameManager.cs =====
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.InputSystem;
using TMPro;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    [Header("UI Panels")]
    public GameObject splashPanel;
    public GameObject menuPanel;
    public GameObject gamePanel;
    public GameObject resultsPanel;

    [Header("Game UI Elements (TMP)")]
    public TMP_Text scoreText;
    public TMP_Text highscoreText;
    public TMP_Text roundText;
    public TMP_Text livesText;
    public TMP_Text finalScoreText;  // WICHTIG f�r Game Over

    [Header("Settings")]
    public int maxLives = 3;
    public float splashDuration = 3.0f;

    public enum GameState { Splash, Menu, Game, Results }
    public GameState CurrentState { get; private set; }

    private int score;
    private int highscore;
    private int round;
    private int currentLives;
    private float timer;

    void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    void Start()
    {
        highscore = PlayerPrefs.GetInt("Highscore", 0);
        UpdateGameUI();
        ChangeState(GameState.Splash);
    }

    void Update()
    {
        if (CurrentState == GameState.Splash)
        {
            timer += Time.deltaTime;
            bool mouseClicked = Mouse.current != null && Mouse.current.leftButton.wasPressedThisFrame;
            if (timer >= splashDuration || mouseClicked) ChangeState(GameState.Menu);
        }
    }

    public void ChangeState(GameState newState)
    {
        CurrentState = newState;

        if (splashPanel) splashPanel.SetActive(false);
        if (menuPanel) menuPanel.SetActive(false);
        if (gamePanel) gamePanel.SetActive(false);
        if (resultsPanel) resultsPanel.SetActive(false);

        switch (newState)
        {
            case GameState.Splash:
                if (splashPanel) splashPanel.SetActive(true);
                timer = 0f;
                break;
            case GameState.Menu:
                if (menuPanel) menuPanel.SetActive(true);
                if (BackgroundMusicManager.Instance != null) BackgroundMusicManager.Instance.StartMusic();
                break;
            case GameState.Game:
                if (gamePanel) gamePanel.SetActive(true);
                UpdateGameUI();
                break;
            case GameState.Results:
                if (resultsPanel) resultsPanel.SetActive(true);
                // HIER: Den finalen Score in den Text schreiben
                if (finalScoreText) finalScoreText.text = $"Final Score: {score}";
                break;
        }
    }

    public void StartGame()
    {
        score = 0;
        currentLives = maxLives;
        round = 1;
        UpdateGameUI();
        ChangeState(GameState.Game);
    }

    // Wird vom TrainController aufgerufen
    public void OnTrainDeparted(bool wasFull)
    {
        if (CurrentState != GameState.Game) return;

        if (wasFull)
        {
            // Zug voll -> Punkte, KEIN Leben verloren
            score += 100;
            if (score > highscore)
            {
                highscore = score;
                PlayerPrefs.SetInt("Highscore", highscore);
                PlayerPrefs.Save();
            }
            Debug.Log("Zug voll! +100 Punkte");
        }
        else
        {
            // Zug nicht voll -> Leben verlieren
            currentLives--;
            Debug.Log("Zug nicht voll! Leben verloren.");

            if (currentLives <= 0)
            {
                TriggerGameOver();
                return; // Wichtig: Hier abbrechen, damit Runde nicht hochz�hlt
            }
        }

        // Wenn noch Leben da sind, n�chste Runde
        round++;
        UpdateGameUI();
    }

    void UpdateGameUI()
    {
        if (scoreText) scoreText.text = $"Score: {score}";
        if (livesText) livesText.text = $"Lives: {currentLives}";
        if (highscoreText) highscoreText.text = $"Highscore: {highscore}";
        if (roundText) roundText.text = $"Round: {round}";
    }

    public void TriggerGameOver()
    {
        ChangeState(GameState.Results);
    }

    public bool IsGameRunning() => CurrentState == GameState.Game;

    public void OnStartGameButton() => StartGame();
    public void OnRestartButton() => SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    public void OnQuitButton() => Application.Quit();
}
===== END: GameManager.cs =====


===== FILE: GiftDespawner.cs =====
using UnityEngine;

public class GiftDespawner : MonoBehaviour
{
    [Header("Settings")]
    public float lifetime = 10f; // Wie lange existiert es insgesamt?
    public float startBlinkingAt = 3f; // Ab wann (Restzeit) soll es blinken?

    [Header("Blink Speed")]
    public float slowBlinkInterval = 0.5f; // Langsames Blinken (Anfang)
    public float fastBlinkInterval = 0.1f; // Schnelles Flackern (Ende)

    private float age;
    private float blinkTimer;
    private Renderer[] renderers; // Alle MeshRenderer (falls das Geschenk aus mehreren Teilen besteht)
    private bool isVisible = true;

    void Start()
    {
        // Wir holen uns alle Renderer (auch von Kind-Objekten), damit das ganze Geschenk blinkt
        renderers = GetComponentsInChildren<Renderer>();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;

        age += Time.deltaTime;
        float remainingTime = lifetime - age;

        // 1. Zeit abgelaufen? -> Weg damit
        if (remainingTime <= 0)
        {
            Destroy(gameObject);
            return;
        }

        // 2. Soll es blinken? (Nur in den letzten X Sekunden)
        if (remainingTime <= startBlinkingAt)
        {
            HandleBlinking(remainingTime);
        }
    }

    void HandleBlinking(float remainingTime)
    {
        // Berechne, wie weit wir im Blink-Prozess sind (0 = Start Blinken, 1 = Tot)
        // Wir kehren den Wert um, damit 1.0 = Start (3 sek) und 0.0 = Ende (0 sek) ist, das macht Lerp einfacher
        float progress = remainingTime / startBlinkingAt;

        // Lerp: Wir berechnen das aktuelle Intervall basierend auf der Restzeit.
        // Wenn noch viel Zeit ist (progress 1), nutzen wir slowBlinkInterval.
        // Wenn wenig Zeit ist (progress 0), nutzen wir fastBlinkInterval.
        float currentInterval = Mathf.Lerp(fastBlinkInterval, slowBlinkInterval, progress);

        blinkTimer += Time.deltaTime;

        // Ist es Zeit den Status zu wechseln?
        if (blinkTimer >= currentInterval)
        {
            ToggleVisuals();
            blinkTimer = 0f;
        }
    }

    void ToggleVisuals()
    {
        isVisible = !isVisible;

        // Alle Renderer an/ausschalten
        foreach (var rend in renderers)
        {
            rend.enabled = isVisible;
        }
    }
}
===== END: GiftDespawner.cs =====


===== FILE: GiftSpawner.cs =====
using UnityEngine;

public class GiftSpawner : MonoBehaviour
{
    [Header("Geschenke Varianten")]
    public GameObject giftPrefabA; // Erstes Design (z.B. Rot)
    public GameObject giftPrefabB; // Zweites Design (z.B. Blau)

    [Header("Settings")]
    public float spawnInterval = 2.0f;
    public float spawnY = 0.5f;

    [Header("Spawn Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;

    private float timer;
    private bool spawnNextTypeA = true; // Schalter f�r Abwechslung

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;

        timer += Time.deltaTime;

        if (timer >= spawnInterval)
        {
            SpawnAlternatingGift();
            timer = 0f;
        }
    }

    void SpawnAlternatingGift()
    {
        // Zufallsposition
        float randomX = Random.Range(minX, maxX);
        float randomZ = Random.Range(minZ, maxZ);
        Vector3 spawnPos = new Vector3(randomX, spawnY, randomZ);

        // Welches Prefab?
        GameObject prefabToSpawn = spawnNextTypeA ? giftPrefabA : giftPrefabB;

        if (prefabToSpawn != null)
        {
            Instantiate(prefabToSpawn, spawnPos, Quaternion.identity);
        }

        // Schalter umlegen f�r das n�chste Mal
        spawnNextTypeA = !spawnNextTypeA;
    }
}
===== END: GiftSpawner.cs =====


===== FILE: PlayerController.cs =====
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.UI;
using TMPro;

[RequireComponent(typeof(CharacterController))]
public class PlayerController : MonoBehaviour
{
    // ... (Andere Variablen wie bisher lassen) ...
    [Header("Movement & Speed")]
    public float baseMoveSpeed = 10f;
    public float rotateSpeed = 10f;
    public TMP_Text speedDisplayUI;

    [Header("Boundaries")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;
    public float fixedY = 0f;

    [Header("Animation")]
    public Animator animator;
    public bool useAnimation = true;
    public string moveParameterName = "IsMoving";

    [Header("Stack Settings")]
    public Transform stackPoint;
    public float stackOffsetY = 0.9f;
    public float stackOffsetZ = 0.6f;
    public int maxStackSize = 20;

    private CharacterController controller;
    private List<GameObject> currentStack = new List<GameObject>();
    private float currentSpeed;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        if (animator == null) animator = GetComponentInChildren<Animator>();
        UpdateSpeedAndUI();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning())
        {
            if (useAnimation && animator != null) animator.SetBool(moveParameterName, false);
            return;
        }
        Move();
    }

    // ... (Move, OnTriggerEnter, CollectGift, DropAllGifts bleiben GLEICH wie vorher) ...
    // ... (Kopiere hier deine Move, OnTriggerEnter, CollectGift, DropAllGifts Methoden rein) ...
    // Ich k�rze das hier ab, damit du nur das Neue siehst:

    void Move()
    {
        // (Dein bestehender Move-Code)
        float x = 0f;
        float z = 0f;
        if (Keyboard.current != null)
        {
            if (Keyboard.current.aKey.isPressed || Keyboard.current.leftArrowKey.isPressed) x -= 1f;
            if (Keyboard.current.dKey.isPressed || Keyboard.current.rightArrowKey.isPressed) x += 1f;
            if (Keyboard.current.sKey.isPressed || Keyboard.current.downArrowKey.isPressed) z -= 1f;
            if (Keyboard.current.wKey.isPressed || Keyboard.current.upArrowKey.isPressed) z += 1f;
        }
        Vector3 direction = new Vector3(x, 0, z).normalized;
        bool isMoving = direction.magnitude >= 0.1f;

        if (useAnimation && animator != null) animator.SetBool(moveParameterName, isMoving);

        if (isMoving)
        {
            float targetAngle = Mathf.Atan2(direction.x, direction.z) * Mathf.Rad2Deg;
            transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.Euler(0f, targetAngle, 0f), Time.deltaTime * rotateSpeed);
            Vector3 moveVector = direction * currentSpeed * Time.deltaTime;
            controller.Move(moveVector);
        }

        Vector3 finalPos = transform.position;
        finalPos.x = Mathf.Clamp(finalPos.x, minX, maxX);
        finalPos.z = Mathf.Clamp(finalPos.z, minZ, maxZ);
        finalPos.y = fixedY;
        transform.position = finalPos;
    }

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Gift"))
        {
            if (currentStack.Count < maxStackSize) CollectGift(other.gameObject);
        }
        else if (other.CompareTag("Snowman"))
        {
            DropAllGifts();
        }
    }

    void CollectGift(GameObject groundGift)
    {
        Collider col = groundGift.GetComponent<Collider>();
        if (col != null) col.enabled = false;
        GiftDespawner despawner = groundGift.GetComponent<GiftDespawner>();
        if (despawner != null) Destroy(despawner);

        groundGift.transform.SetParent(stackPoint);
        float newY = currentStack.Count * stackOffsetY;
        groundGift.transform.localPosition = new Vector3(0f, newY, stackOffsetZ);
        groundGift.transform.localRotation = Quaternion.identity;
        currentStack.Add(groundGift);
        UpdateSpeedAndUI();
    }

    void DropAllGifts()
    {
        if (currentStack.Count == 0) return;
        foreach (var gift in currentStack)
        {
            gift.transform.SetParent(null);
            Vector2 randomCircle = Random.insideUnitCircle * 3f;
            Vector3 dropPos = transform.position + new Vector3(randomCircle.x, 0.5f, randomCircle.y);
            dropPos.x = Mathf.Clamp(dropPos.x, minX, maxX);
            dropPos.z = Mathf.Clamp(dropPos.z, minZ, maxZ);
            gift.transform.position = dropPos;
            gift.transform.rotation = Quaternion.identity;

            Collider col = gift.GetComponent<Collider>();
            if (col != null) col.enabled = true;
            if (gift.GetComponent<GiftDespawner>() == null) gift.AddComponent<GiftDespawner>();
        }
        currentStack.Clear();
        UpdateSpeedAndUI();
    }

    void UpdateSpeedAndUI()
    {
        float fullness = (float)currentStack.Count / (float)maxStackSize;
        float speedFactor = 1.0f - (0.5f * fullness);
        currentSpeed = baseMoveSpeed * speedFactor;

        if (speedDisplayUI != null)
        {
            int displayPercent = Mathf.RoundToInt(speedFactor * 100);
            speedDisplayUI.text = $"Speed: {displayPercent}%";
            if (displayPercent > 75) speedDisplayUI.color = Color.green;
            else if (displayPercent > 50) speedDisplayUI.color = Color.yellow;
            else speedDisplayUI.color = Color.red;
        }
    }

    // --- HIER IST DIE NEUE FUNKTION ---
    // Gibt maximal 'neededAmount' zur�ck und beh�lt den Rest
    public int GiveGifts(int neededAmount)
    {
        // Wir k�nnen maximal so viele geben, wie wir haben
        int amountToGive = Mathf.Min(currentStack.Count, neededAmount);

        // Wir entfernen die obersten Geschenke (vom Ende der Liste)
        for (int i = 0; i < amountToGive; i++)
        {
            // Immer das letzte Element nehmen
            int lastIndex = currentStack.Count - 1;
            GameObject gift = currentStack[lastIndex];

            // Aus Liste entfernen
            currentStack.RemoveAt(lastIndex);

            // Objekt zerst�ren (es ist ja jetzt im Zug)
            Destroy(gift);
        }

        UpdateSpeedAndUI(); // Speed wieder erh�hen!
        return amountToGive;
    }
}
===== END: PlayerController.cs =====


===== FILE: SnowmanController.cs =====
using UnityEngine;
using System.Collections;

[RequireComponent(typeof(CharacterController))] // Erzwingt den Controller
public class SnowmanController : MonoBehaviour
{
    [Header("Movement")]
    public float moveSpeed = 3f;
    public float waitTime = 2f;
    public float rotateSpeed = 5f;

    [Header("Wander Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;

    // HIER: Damit nageln wir ihn auf dem Boden fest, genau wie den Player
    public float fixedY = 0f;

    [Header("Model Correction")]
    // Wenn dein Modell liegt, drehen wir das Visual-Child oder das Objekt selbst.
    // Falls das ganze Objekt gedreht werden muss:
    public float xRotationCorrection = -90f;

    private Vector3 targetPosition;
    private float timer;
    private bool isWaiting;
    private bool isSpawning = true;

    private CharacterController controller;

    void Start()
    {
        controller = GetComponent<CharacterController>();

        // Sofortige Korrektur der Rotation beim Start
        // Wir setzen die Rotation hart, damit er steht
        transform.rotation = Quaternion.Euler(xRotationCorrection, 0f, 0f);

        StartCoroutine(RiseFromGround());
    }

    IEnumerator RiseFromGround()
    {
        isSpawning = true;

        // Startposition (unter der Erde)
        Vector3 startPos = transform.position;
        // Zielposition (auf dem Boden)
        Vector3 endPos = new Vector3(startPos.x, fixedY, startPos.z);

        float elapsed = 0f;
        float duration = 1.5f;

        while (elapsed < duration)
        {
            // Wir bewegen nur die Position, Rotation bleibt fest korrigiert
            transform.position = Vector3.Lerp(startPos, endPos, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.position = endPos;
        isSpawning = false;
        SetNewRandomTarget();
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning()) return;
        if (isSpawning) return;

        // Wir erzwingen permanent die X-Rotation, falls die Physik sie verhaut
        // Aber wir erlauben Y-Rotation (drehen zum Ziel)
        float currentYRot = transform.rotation.eulerAngles.y;
        transform.rotation = Quaternion.Euler(xRotationCorrection, currentYRot, 0f);

        if (isWaiting)
        {
            timer -= Time.deltaTime;
            if (timer <= 0)
            {
                isWaiting = false;
                SetNewRandomTarget();
            }
        }
        else
        {
            MoveToTarget();
        }
    }

    void MoveToTarget()
    {
        // 1. Richtung berechnen (nur X und Z, Y ignorieren wir)
        Vector3 direction = (targetPosition - transform.position).normalized;
        direction.y = 0; // Wichtig: Keine Bewegung nach oben/unten berechnen

        if (direction != Vector3.zero)
        {
            // 2. Rotation zum Ziel (aber unter Beibehaltung der -90 X-Rotation)
            Quaternion targetRot = Quaternion.LookRotation(direction);
            // Wir kombinieren die Ziel-Y-Rotation mit deiner festen X-Korrektur
            Quaternion correctedTargetRot = Quaternion.Euler(xRotationCorrection, targetRot.eulerAngles.y, 0f);

            transform.rotation = Quaternion.Slerp(transform.rotation, correctedTargetRot, Time.deltaTime * rotateSpeed);

            // 3. Bewegung mit CharacterController (wie beim Player)
            Vector3 moveVector = direction * moveSpeed * Time.deltaTime;
            controller.Move(moveVector);
        }

        // 4. Ziel erreicht Check
        // Wir ignorieren hier auch die H�he beim Distanz-Check
        Vector3 flatPos = new Vector3(transform.position.x, 0, transform.position.z);
        Vector3 flatTarget = new Vector3(targetPosition.x, 0, targetPosition.z);

        if (Vector3.Distance(flatPos, flatTarget) < 0.2f)
        {
            isWaiting = true;
            timer = waitTime;
        }

        // 5. Hard Fix f�r Position (genau wie beim Player)
        Vector3 clampedPos = transform.position;
        clampedPos.y = fixedY; // Auf Boden zwingen
        transform.position = clampedPos;
    }

    void SetNewRandomTarget()
    {
        float x = Random.Range(minX, maxX);
        float z = Random.Range(minZ, maxZ);
        targetPosition = new Vector3(x, fixedY, z);
    }
}
===== END: SnowmanController.cs =====


===== FILE: SnowmanSpawner.cs =====
using UnityEngine;
using System.Collections.Generic;

public class SnowmanSpawner : MonoBehaviour
{
    public static SnowmanSpawner Instance; // Singleton f�r einfachen Zugriff

    public GameObject snowmanPrefab;
    public int maxSnowmen = 7;

    [Header("Spawn Area")]
    public float minX = -30f;
    public float maxX = 30f;
    public float minZ = -13f;
    public float maxZ = 9f;

    private List<GameObject> activeSnowmen = new List<GameObject>();

    void Awake()
    {
        Instance = this;
    }

    // Wird vom GameManager beim Start aufgerufen (manuell hinzuf�gen im GameManager StartGame w�re sauberer, aber so geht's automatisch)
    void Update()
    {
        // Kleiner Hack: Wenn das Spiel startet und wir haben 0 Schneem�nner, spawn den ersten.
        if (GameManager.Instance.IsGameRunning() && activeSnowmen.Count == 0)
        {
            SpawnSnowman();
        }
    }

    public void SpawnSnowman()
    {
        if (activeSnowmen.Count >= maxSnowmen) return;

        float randomX = Random.Range(minX, maxX);
        float randomZ = Random.Range(minZ, maxZ);

        // Startposition unter der Erde (Y = -2)
        Vector3 spawnPos = new Vector3(randomX, -2f, randomZ);

        GameObject newSnowman = Instantiate(snowmanPrefab, spawnPos, Quaternion.identity);
        activeSnowmen.Add(newSnowman);
    }

    public void ResetSnowmen()
    {
        foreach (var snowman in activeSnowmen)
        {
            Destroy(snowman);
        }
        activeSnowmen.Clear();
        // Der erste spawnt dann wieder automatisch im Update
    }
}
===== END: SnowmanSpawner.cs =====


===== FILE: TrainController.cs =====
using UnityEngine;
using UnityEngine.UI; // F�r Slider
using TMPro;          // WICHTIG: F�r TextMeshPro

[RequireComponent(typeof(AudioSource))]
public class TrainController : MonoBehaviour
{
    [Header("Settings")]
    public float speed = 15f;
    public float waitTime = 10f;
    public float spawnX = 60f;
    public float stopX = 0f;
    public float despawnX = -80f;

    // NEU: Festgelegte Anzahl (Standard 10)
    public int giftsNeededPerRound = 10;

    [Header("Audio")]
    public AudioClip arrivalSound;

    [Header("Visuals")]
    public GameObject emptyWagonVisual;
    public GameObject fullWagonVisual;

    [Header("UI (World Space)")]
    public Slider timerSlider;   // Der existierende Timer-Slider (wenn du ihn behalten willst)

    // NEU: Slider und Text f�r die Pakete
    public Slider cargoSlider;
    public TMP_Text cargoText;       // "0 / 10"

    private bool isWaiting = false;
    private bool isLeaving = false;
    private float currentWaitTimer;
    private int currentGifts = 0;
    private int requiredGifts;
    private bool wasFullWhenDeparted = false;
    private AudioSource audioSource;

    void Start()
    {
        audioSource = GetComponent<AudioSource>();
        audioSource.playOnAwake = false;
        audioSource.loop = false;
        ResetTrain(true);
    }

    void Update()
    {
        if (GameManager.Instance != null && !GameManager.Instance.IsGameRunning())
        {
            if (audioSource.isPlaying) audioSource.Pause();
            return;
        }
        else
        {
            audioSource.UnPause();
        }

        // 1. Einfahren
        if (!isWaiting && !isLeaving)
        {
            Vector3 targetPos = new Vector3(stopX, transform.position.y, transform.position.z);
            transform.position = Vector3.MoveTowards(transform.position, targetPos, speed * Time.deltaTime);

            if (Mathf.Abs(transform.position.x - stopX) < 0.1f)
            {
                StartWaiting();
            }
        }
        // 2. Warten
        else if (isWaiting)
        {
            // Visual Update wenn voll
            if (currentGifts >= requiredGifts && !fullWagonVisual.activeSelf) SetWagonVisuals(true);

            currentWaitTimer -= Time.deltaTime;

            // Timer Slider Logik (optional, falls du den noch nutzt)
            if (timerSlider) timerSlider.value = currentWaitTimer / waitTime;

            // Abfahrtbedingungen: Zeit um ODER (Voll UND kurze Wartezeit vorbei)
            // Wir lassen ihn sofort abfahren, wenn er voll ist? Oder soll er warten? 
            // Dein Code war: Er f�hrt ab, wenn Zeit um.
            if (currentWaitTimer <= 0)
            {
                Depart();
            }
        }
        // 3. Abfahren
        else if (isLeaving)
        {
            transform.Translate(Vector3.left * speed * Time.deltaTime);

            if (transform.position.x < despawnX)
            {
                if (SnowmanSpawner.Instance != null) SnowmanSpawner.Instance.SpawnSnowman();

                // Hier checken wir, ob er voll war f�r Punkte/Leben
                GameManager.Instance.OnTrainDeparted(wasFullWhenDeparted);
                ResetTrain(false);
            }
        }
    }

    void StartWaiting()
    {
        isWaiting = true;
        currentWaitTimer = waitTime;

        currentGifts = 0;
        // HIER: Feste Anzahl nehmen statt Random
        requiredGifts = giftsNeededPerRound;

        UpdateUI();
    }

    void Depart()
    {
        isWaiting = false;
        isLeaving = true;
        wasFullWhenDeparted = (currentGifts >= requiredGifts);
    }

    void ResetTrain(bool initial)
    {
        transform.position = new Vector3(spawnX, transform.position.y, transform.position.z);
        isLeaving = false;
        isWaiting = false;
        SetWagonVisuals(false);

        if (arrivalSound != null)
        {
            audioSource.clip = arrivalSound;
            audioSource.Play();
        }

        if (initial && SnowmanSpawner.Instance != null)
        {
            SnowmanSpawner.Instance.ResetSnowmen();
        }
    }

    void SetWagonVisuals(bool isFull)
    {
        if (emptyWagonVisual) emptyWagonVisual.SetActive(!isFull);
        if (fullWagonVisual) fullWagonVisual.SetActive(isFull);
    }

    void UpdateUI()
    {
        // 1. Text aktualisieren ("5 / 10")
        if (cargoText) cargoText.text = $"{currentGifts} / {requiredGifts}";

        // 2. Slider aktualisieren
        if (cargoSlider)
        {
            cargoSlider.maxValue = requiredGifts;
            cargoSlider.value = currentGifts;
        }
    }

    void OnTriggerEnter(Collider other)
    {
        // Nur wenn wir warten und der Spieler kommt
        if (isWaiting && other.CompareTag("Player"))
        {
            PlayerController player = other.GetComponent<PlayerController>();
            if (player != null)
            {
                // WICHTIG: Berechnen, wie viele noch fehlen
                int missing = requiredGifts - currentGifts;

                if (missing > 0)
                {
                    // Wir nehmen nur so viele vom Spieler, wie fehlen!
                    int taken = player.GiveGifts(missing);

                    currentGifts += taken;
                    UpdateUI();

                    if (currentGifts >= requiredGifts)
                    {
                        SetWagonVisuals(true);
                        // Optional: Wenn voll, sofort Abfahrt-Timer verk�rzen?
                        // currentWaitTimer = 1.0f; // z.B. nur noch 1 Sekunde warten
                    }
                }
            }
        }
    }
}
===== END: TrainController.cs =====


